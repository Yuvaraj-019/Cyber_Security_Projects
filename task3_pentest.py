#!/usr/bin/env python3
# =============================================================
# pentest_toolkit.py
# Merged Penetration Testing Toolkit (single-file)
# Updated: Adds delay and logging to brute-force module.
#
# Modules:
#   1) Port Scanner (threaded)
#   2) Directory Scanner (common directories + optional wordlist)
#   3) Brute Force (HTTP POST demo) — now with delay & logging
#
# Usage:
#   python pentest_toolkit.py
#
# Author: Atreus (template). Updated for user.
# =============================================================

import os
import sys
import socket
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urljoin
import requests
import time
from datetime import datetime

# -------------------- Utilities --------------------

def clear_screen():
    os.system("cls" if os.name == "nt" else "clear")

def prompt_enter():
    input("\nPress Enter to continue...")

# -------------------- Port Scanner --------------------

def scan_port(host, port, timeout=0.8):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(timeout)
    try:
        s.connect((host, port))
        s.close()
        return port, True
    except:
        return port, False

def port_scan_range(host, start=1, end=1024, workers=200):
    open_ports = []
    # Validate host resolution
    try:
        socket.gethostbyname(host)
    except Exception as e:
        raise RuntimeError(f"Host resolution failed: {e}")

    ports = range(start, end + 1)
    with ThreadPoolExecutor(max_workers=min(workers, len(ports))) as ex:
        futures = {ex.submit(scan_port, host, p): p for p in ports}
        for fut in as_completed(futures):
            p, is_open = fut.result()
            if is_open:
                open_ports.append(p)
    open_ports.sort()
    return open_ports

# -------------------- Directory Scanner --------------------

COMMON_DIRS = [
    "admin", "administrator", "login", "backup", "backups", "uploads", "upload",
    "test", "old", "portal", "config", "cfg", "server-status", "phpinfo.php"
]

def scan_directories(base_url, wordlist_path=None, timeout=5):
    # Ensure base_url ends with slash
    if not base_url.endswith("/"):
        base_url += "/"
    words = []
    if wordlist_path:
        try:
            with open(wordlist_path, "r", encoding="utf-8", errors="ignore") as f:
                words = [w.strip() for w in f if w.strip()]
        except Exception as e:
            raise RuntimeError(f"Could not read wordlist: {e}")
    else:
        words = COMMON_DIRS

    found = []
    for w in words:
        url = urljoin(base_url, w)
        try:
            r = requests.get(url, timeout=timeout, allow_redirects=False)
            # Consider things other than 404 as interesting (200, 301, 302, 403 etc.)
            if r.status_code != 404:
                found.append((url, r.status_code))
        except requests.RequestException:
            continue
    return found

# -------------------- Brute Force (Demo) w/ Delay & Logging --------------------

def write_brutelog(logfile, entry):
    """Append a single line to log file with timestamp."""
    try:
        with open(logfile, "a", encoding="utf-8") as f:
            f.write(entry + "\n")
    except Exception as e:
        print(f"[!] Failed to write log: {e}")

def simple_post_bruteforce(login_url, username_field, password_field,
                           usernames, passwords, delay=0.5, logfile="bruteforce_log.txt",
                           timeout=6):
    """
    Minimal demo brute force with delay and logging.
    - usernames: list of usernames
    - passwords: list of passwords
    - delay: seconds to sleep between attempts (float)
    - logfile: path to append attempt/result logs
    Returns: list of detected results (username, password, note)
    """
    results = []
    session = requests.Session()

    header = f"[BRUTE LOG START] {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} | target: {login_url}"
    write_brutelog(logfile, header)

    total = len(usernames) * len(passwords)
    attempt_no = 0
    for u in usernames:
        for p in passwords:
            attempt_no += 1
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            note = "no-result"
            try:
                r = session.post(login_url, data={username_field: u, password_field: p},
                                 timeout=timeout, allow_redirects=False)
                status = r.status_code
                body = r.text.lower()
                # Heuristics
                if status in (301, 302):
                    note = f"redirected ({status})"
                    results.append((u, p, note))
                elif any(k in body for k in ("logout", "dashboard", "welcome", "profile")):
                    note = "likely success (keyword)"
                    results.append((u, p, note))
                else:
                    note = f"no-match ({status})"
            except requests.RequestException as e:
                note = f"error ({e.__class__.__name__})"

            log_line = f"{timestamp} | attempt {attempt_no}/{total} | user={u} | pass={p} | result={note}"
            write_brutelog(logfile, log_line)

            # Console feedback (short)
            print(f"[{attempt_no}/{total}] {u}:{p} -> {note}")

            # delay between attempts to avoid rate-limit / be polite
            try:
                time.sleep(float(delay))
            except Exception:
                time.sleep(0.5)  # fallback

    footer = f"[BRUTE LOG END] {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} | total attempts: {attempt_no}"
    write_brutelog(logfile, footer)

    return results

# -------------------- CLI Menu --------------------

def menu():
    while True:
        clear_screen()
        print("=" * 60)
        print("        PENETRATION TESTING TOOLKIT (Demo / Educational)")
        print("=" * 60)
        print("1) Port Scanner")
        print("2) Directory Scanner")
        print("3) Brute Force (HTTP POST demo) - with delay & logging")
        print("4) Exit")
        print("-" * 60)
        choice = input("Choose an option (1-4): ").strip()

        if choice == "1":
            host = input("Target host (IP or domain): ").strip()
            try:
                start = int(input("Start port [1]: ") or 1)
                end = int(input("End port [1024]: ") or 1024)
                workers = int(input("Max threads [200]: ") or 200)
            except ValueError:
                print("[!] Invalid numeric input.")
                prompt_enter()
                continue

            print(f"\nScanning {host} ports {start}–{end} (this may take a while)...")
            t0 = time.time()
            try:
                open_ports = port_scan_range(host, start, end, workers)
            except Exception as e:
                print(f"[!] Error: {e}")
                prompt_enter()
                continue
            t1 = time.time()
            print(f"\n[✔] Scan complete (time: {t1-t0:.2f}s). Open ports:")
            if open_ports:
                for p in open_ports:
                    print(f"  - {p}")
            else:
                print("  None found in the specified range.")
            prompt_enter()

        elif choice == "2":
            base_url = input("Base URL (e.g. https://example.com/): ").strip()
            wl = input("Optional wordlist file path (press Enter to use common list): ").strip() or None
            print(f"\nScanning common directories on {base_url} ...")
            try:
                found = scan_directories(base_url, wl)
            except Exception as e:
                print(f"[!] Error: {e}")
                prompt_enter()
                continue
            if found:
                print("\n[✔] Interesting endpoints:")
                for url, code in found:
                    print(f"  - {url}  (HTTP {code})")
            else:
                print("\n[!] No interesting directories found (quick scan).")
            prompt_enter()

        elif choice == "3":
            print("\n=== Brute Force (DEMO - authorized targets only) ===")
            login_url = input("Login URL (full path to form action) e.g. http://127.0.0.1:5000/login: ").strip()
            user_field = input("Username field name [username]: ").strip() or "username"
            pass_field = input("Password field name [password]: ").strip() or "password"
            wl_user = input("Comma-separated usernames (press Enter for defaults [admin,test,user]): ").strip()
            wl_pass = input("Comma-separated passwords (press Enter for defaults [admin,password,123456]): ").strip()
            delay_input = input("Delay between attempts in seconds (e.g. 0.5) [0.5]: ").strip() or "0.5"
            logfile = input("Log file to append attempts [bruteforce_log.txt]: ").strip() or "bruteforce_log.txt"

            # Build username/password lists
            usernames = [u.strip() for u in wl_user.split(",") if u.strip()] or ["admin", "test", "user"]
            passwords = [p.strip() for p in wl_pass.split(",") if p.strip()] or ["admin", "password", "123456"]

            print(f"\nRunning demo brute force against {login_url} (only for authorized targets)...")
            print(f"Attempts: {len(usernames) * len(passwords)} | delay: {delay_input}s | log: {logfile}\n")
            results = simple_post_bruteforce(login_url, user_field, pass_field,
                                             usernames, passwords, delay=delay_input, logfile=logfile)
            if results:
                print("\n[✔] Potential results found:")
                for r in results:
                    print(f"  - username: {r[0]} | password: {r[1]} | note: {r[2]}")
                print(f"\n[ℹ] All attempts were logged to '{logfile}'.")
            else:
                print("\n[!] No successful attempts detected (demo heuristics).")
                print(f"[ℹ] All attempts were logged to '{logfile}'.")
            prompt_enter()

        elif choice == "4":
            print("\nExiting. Stay legal and ethical!")
            break
        else:
            print("\n[!] Invalid choice.")
            prompt_enter()

# -------------------- Entry Point --------------------

if __name__ == "__main__":
    try:
        menu()
    except KeyboardInterrupt:
        print("\n\nInterrupted by user. Exiting.")
        sys.exit(0)
